"""
Generates an instructions file.
"""
import datetime
import dis
import sys
import warnings
from io import StringIO

if sys.implementation.name != "cpython":
    warnings.warn("There's not much point running this on non-CPython")

version = sys.version.replace("\n", " ")
gen_fmt = f"This file was generated using {sys.implementation.name}\n" \
          f" * version {version}\n" \
          f" * on {datetime.datetime.utcnow().isoformat()}"

header = rf"""/**
 * This file is automatically generated by running gen_instructionsky.py.
 * Do not edit yourself!
 * {gen_fmt}
 */

@Suppress("SpellCheckingInspection", "unused")
enum class InstructionOpcode(
    /** The raw int opcode. */
    val opcode: Int,
    /** If this instruction operates on a const. */
    val hasConst: Boolean,
    /** If this instruction operates on a free variable. */
    val hasFree: Boolean,
    /** If this instruction operates on a named variable. */
    val hasName: Boolean,
    /** If this instruction has a relative jump. */
    val hasRelJump: Boolean,
    /** If this instruction has an absolute jump. */
    val hasAbsJump: Boolean,
    /** If this instruction operators on a local variable. */
    val hasLocal: Boolean,
    /** If this instruction is used for comparison. */
    val hasCmp: Boolean
) {{
"""

buf = StringIO()
buf.write(header)

for idx, (name, opcode) in enumerate(dis.opmap.items()):
    _ = lambda i: "true" if i else "false"
    has_const = _(opcode in dis.hasconst)
    has_free = _(opcode in dis.hasfree)
    has_name = _(opcode in dis.hasname)
    has_rel_jump = _(opcode in dis.hasjrel)
    has_abs_jump = _(opcode in dis.hasjabs)
    has_local = _(opcode in dis.haslocal)
    has_cmp = _(opcode in dis.hascompare)
    buf.write(f"    {name}({opcode}, {has_const}, {has_free}, "
              f"{has_name}, {has_rel_jump}, {has_abs_jump}, "
              f"{has_local}, {has_cmp})")

    if idx + 1 == len(dis.opmap):
        buf.write(";\n")
    else:
        buf.write(",\n")


# once again, for the companion object
cobject = """
    companion object {
        /**
         * Gets an opcode by int.
         */
        fun get(opcode: Int): InstructionOpcode {
            return when (opcode) {
"""
buf.write(cobject)
for name, opcode in dis.opmap.items():
    buf.write(" " * 16 + f"{opcode} -> {name}\n")

buf.write(" " * 16 + f"else -> error(\"Unknown opcode $opcode\")\n")
buf.write(" " * 12 + "}\n")  # when last brace
buf.write(" " * 8 + "}\n")  # get() last brace
buf.write(" " * 4 + "}\n")  # companion last brace
buf.write("}\n")  # enum last brace

print(buf.getvalue())
